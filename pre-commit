#!/usr/bin/env bash

# SPDX-License-Identifier: Apache-2.0
# Source: https://github.com/loverdos/pre-commit

# The script serves as a runner for the `git` pre-commit hook.
# It assumes a series of scripts are placed in the `.pre-commit/` folder,
# and runs them all.
#
# Requirements: recent `bash`, `git`, `shellcheck`.
# On macOS the built-in `bash` may not work, so install from `brew`.
# Tested-on: macOS, Linux

# shellcheck disable=SC2034
SCRIPT_VERSION=18

# shellcheck disable=SC2034
SCRIPT_ID=AF13AE47-34E0-41FA-8FF8-AF660A922C6A

set -euo pipefail

pre_commit=pre-commit

org=loverdos
repo=$pre_commit

dot_pre_commit=.$pre_commit
dot_pre_commit_pre_commit=$dot_pre_commit/$pre_commit

dot_script_id=.script_id

function LOG() {
    echo "== $*" >&2
}

function run() {
    local cmds=()
    local cmd_statuses=()
    local successes=0
    local failures=0
    local mark=""
    local script_seconds=0
    local script_time=""
    local script_times=()

    function sec_to_mmss() {
        local time_sec=$1
        local time_min=$((time_sec / 60))
        time_sec=$((time_sec % 60))

        printf "%02d:%02d" $time_min $time_sec
    }

    LOG "Running pre-commit hook"
    SECONDS=0 # bash builtin ;)

    # We must always be in a git work tree.
    git_root=$(git rev-parse --show-toplevel 2>/dev/null) || {
        LOG "Error: $(pwd) is not a Git work tree"
        return 1
    }

    cd "$git_root"

    set +e
    for script in "$dot_pre_commit"/*; do
        # We do not want to run ourselves recursively ...
        if [[ "$script" == "$dot_pre_commit_pre_commit" || "$script" == "$dot_pre_commit_pre_commit".* ]]; then
            continue
        fi

        LOG
        LOG "Run: $script"

        script_seconds=$SECONDS
        
        $script
        status=$?
        
        script_seconds=$((SECONDS - script_seconds))

        cmds+=("$script")
        cmd_statuses+=("$status")

        script_time=$(sec_to_mmss $script_seconds)
        script_times+=("$script_time")

        if ((status == 0)); then
            ((successes++))
            mark="✅"
        else
            ((failures++))
            mark="❌"
        fi

        LOG "Exit: $mark [= $status] $script"
    done
    set -e

    time=$(sec_to_mmss $SECONDS)

    LOG
    LOG "Results: $successes success(es), $failures failure(s)"
    LOG "     In: $time [min:sec]"
    LOG

    local result=0

    for i in "${!cmds[@]}"; do
        if ((cmd_statuses[i] == 0)); then
            LOG "✅ [${script_times[i]}] ${cmds[i]}"
        else
            LOG "❌ [${script_times[i]}] ${cmds[i]}"
            result=1
        fi
    done

    LOG

    return $result
}

run