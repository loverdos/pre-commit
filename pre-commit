#!/usr/bin/env bash

# SPDX-License-Identifier: Apache-2.0
# Source: https://github.com/loverdos/pre-commit

# shellcheck disable=SC2034
SCRIPT_VERSION=10

# shellcheck disable=SC2034
SCRIPT_ID=AF13AE47-34E0-41FA-8FF8-AF660A922C6A

# Requirements: recent `bash`, `curl`, `git`, and some other general utilities.
# On macOS the built-in `bash` may not work, so install from `brew`.
# Tested-on: macOS, Linux
# Tested-on: fish, bash

# Manages the `git` pre-commit hook.
# The script serves both as an installer for itself and a hook runner.
#
# To install, you need to be in a `git` working tree already, and run
# the following:
#
#   curl -fsSL https://raw.githubusercontent.com/loverdos/pre-commit/main/pre-commit -o pre-commit && chmod +x pre-commit && ./pre-commit --install
#
# This does the following:
#   - Creates a `.pre-commit` folder in the repo, and places the current script there.
#   - Makes sure that `.git/hooks/pre-commit` links to the above.
#     A pre-existing `.git/hooks/pre-commit` is backed up in `.git/hooks`.
#
# In the `.pre-commit` folder you place the scripts to run before any `git commit`.
# Apparently, none of them should be named `pre-commit`.
# That's it.
#
# Developing the script itself:
#   1. # ... make changes
#   2. ./pre-commit --install
#   3. git commit
#
# We assume `shellcheck` is installed.

set -euo pipefail

MY_URL=https://raw.githubusercontent.com/loverdos/pre-commit/main/pre-commit
MY_PATH="$0"

pre_commit=pre-commit
repo=$pre_commit
org=loverdos
dot_pre_commit=.$pre_commit
dot_pre_commit_pre_commit=$dot_pre_commit/$pre_commit
dot_git_hooks=.git/hooks
dot_git_hooks_pre_commit=$dot_git_hooks/$pre_commit

cmds=()
cmd_statuses=()
successes=0
failures=0

git_root="$(git rev-parse --show-toplevel)"
dot_script_id=.script_id

function LOG() {
    echo "== $*" >&2
}

function mk_id() {
    echo "$(date -u +%F).$$.$RANDOM"
}

function is_it_me() {
    [[ -f $dot_script_id ]] && [[ $(<"$dot_script_id") == "$SCRIPT_ID" ]] && {
        remote=$(git remote get-url origin)

        [[ $remote == https://github.com/$org/$repo.git || $remote == git@github.com:$org/$repo.git ]]
    }
}

function is_file_or_link() {
    [[ -f "$1" || -L "$1" ]]
}

function is_tracked_in_git() {
    git ls-files --error-unmatch "$1" >/dev/null 2>&1
}

# Check if 'git diff' reports a difference; notice the negation
function has_git_diff() {
    ! git diff --quiet -- $dot_pre_commit_pre_commit
}

function has_diff() {
    # let's use cmp for variety; it should also be faster
    ! cmp -s $dot_pre_commit_pre_commit "$1"
}

function backup_file() {
    file="$1"
    suffix=$(mk_id)
    new_location="$file.$suffix"

    LOG "Backing up $file to $new_location"

    mv "$file" "$new_location"
}

# This function is big because it provides a lot of info/UX (love)
function install() {
    script=$dot_pre_commit_pre_commit

    cd "$git_root"

    if is_it_me; then
        LOG "Hey, I noticed you are messing around with me :)"
    else
        LOG "Begin installation process to $git_root"
    fi

    if is_tracked_in_git $script; then
        # I am tracked by git

        if has_git_diff $script; then
            # The contents committed in git are different than my contents
            LOG "$script exists and is tracked, the script you downloaded is different."
            LOG "I will back up the original"
        else
            # The contents committed in git are the same as my contents
            LOG "$script exists and is tracked, the script you downloaded is at the same version"
        fi
    elif is_file_or_link $script; then # normally it should not be a link ...
        # A file (or link) with the same name exists

        if has_diff $script; then
            LOG "$script exists with different contents, and is not being tracked"
        else
            LOG "$script exists with the same contents, and is not being tracked"
        fi
    else
        # I do not exist here
        LOG "$script does not exist, first time installation"
    fi

    # Make sure all the needed folders exist
    mkdir -p $dot_pre_commit
    mkdir -p $dot_git_hooks

    # Back up the previous version and install the new one.
    if is_file_or_link $script; then
        backup_file $script
    fi
    mv "$MY_PATH" $script

    # Back up the hook and install the new one
    if is_file_or_link $dot_git_hooks_pre_commit; then
        backup_file $dot_git_hooks_pre_commit
    fi
    ln -s "$git_root"/$script $dot_git_hooks_pre_commit

    LOG "Installed version: $SCRIPT_VERSION "
    LOG "               of: $MY_URL"
    LOG "               to: $script"
    LOG "End installation process to $git_root"
}

function check_statuses() {
    LOG
    LOG "Results: $successes success(es), $failures failure(s)"

    result=0
    for i in "${!cmds[@]}"; do
        if ((cmd_statuses[i] == 0)); then
            LOG "✅ ${cmds[i]}"
        else
            LOG "❌ ${cmds[i]}"
            result=1
        fi
    done

    LOG

    exit $result
}

function run() {
    local mark=""

    LOG "Running pre-commit hook(s) from $(pwd)"
    set +e

    cd "$git_root"

    for hook in "$dot_pre_commit"/*; do
        # We do not want to run ourselves recursively ...
        if [[ "$hook" == "$dot_pre_commit_pre_commit" ]]; then
            continue
        fi

        LOG
        LOG "Run: $hook"

        $hook

        status=$?
        cmds+=("$hook")
        cmd_statuses+=("$status")

        if ((status == 0)); then
            ((successes++))
            mark="✅"
        else
            ((failures++))
            mark="❌"
        fi

        LOG "Exit: $mark [= $status] $hook"
    done

    set -e
    check_statuses
}

# We must always be in a git work tree.
if [[ -z "$git_root" ]]; then
    LOG "Error: not inside a Git repository"
    exit 1
fi

# Install ourselves if that is what was requested.
if [[ $# -eq 1 && $1 == "--install" ]]; then
    install
else
    run
fi
